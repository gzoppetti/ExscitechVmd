<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Writing C/C++ based molecule file reader plugins for VMD</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="molfileplugins"><h2>Writing C/C++ based molecule file reader plugins for VMD</h2></a>

<p>
In addition to allowing extensions via the built-in mechanisms of the Tcl and Python languages, VMD also includes its own plugin interface for loading shared object files and dynamic link libraries written in C and C++.
<p>

<p>
 <h3>Main plugin entry points</h3>
 Compiled plugins work by providing a set of standard enry point functions that VMD is able to lookup via the operating system-specific dynamic linking functions. The three main entry points VMD requires from each plugin are:  <ul>
<li>VMDPLUGIN_register <li>VMDPLUGIN_init <li>VMDPLUGIN_fini </ul>
These three entry points are used to load, verify, initialize, and finalize access to a plugin. The register functions perform  plugin/VMD version compatibility tests, initial linking of  callbacks specific to the type and implementation of the plugin. The VMDPLUGIN_init function is called the first time the plugin is  loaded by VMD, and before any other plugin routines or data are referenced, allowing the plugin to have an opportunity to setup any necessary data  structures etc. The VMDPLUGIN_fini function similarly deallocates any internal plugin resources when a plugin is shutdown and unloaded.
<p>
An additional registration entry point is required for plugins which  export new Tcl procedures: <ul>
<li>VMDPLUGIN_register_tcl </ul>

<p>
 <h3>Plugin registration in detail</h3>
 Plugin registration is probably the main concept one needs to understand in order to fully grasp how the whole system works. The basic concept is identical to the methods commonly used in dynamically registering device drivers in operating system kernels. VMD implements a common interface API  that all plugins conform to. The interface API consists of structures which are populated with the name and version information for a plugin, which type of plugin it is, and a set of type-specific function pointers which are either set to NULL (for unsupported features), or to an approprite function which  VMD must call for a given operation.
<p>

<p>
 Since VMD and the plugins it interfaces to must share common data  structures used in the plugin API, one of the first things the plugin system does is to compare version numbers which are hard-coded into the header files that both the interface and the plugins are compiled  against. Whenever the contents or layout of these common interface structures is changed, the version numbers in the header files are  also updated. This gaurantees that the plugins and the plugin interface software are storing the same values in the same locations of these common structures, and that they agree on the semantics of these values. This is not quite enough to gaurantee that all compilers will pack these data structures in exactly the same way, but it does gaurantee that as long as one uses compilers that are otherwise compatible with each other to compile VMD and its plugins that they will work together.
<p>

<p>
 Much like a device driver in Unix would register functions for  operations such as open, close, read, write, and ioctl, a VMD plugin provides operations for open, close, read structure, write  structure, read bonds, read coordinates, and various other operations which are specific to the type of plugin. Molecule file plugins support operations and function pointers which are oriented specifically towards manipulating files containing molecular structures and density data. Import graphics plugins on the other hand, only contain operations and functions for reading and writing purely geometric data such as triangles,  spheres, and so on.
<p>

<p>
 <h3>Plugin code development issues</h3>
 In addition to the general structural requirements that all plugins must conform to, there are also several required code  design practices which are required in order to achieve portability and reliable operation.
<p>

<p>
 Plugins written in C++ should avoid using templates entirely. It is difficult to force templates to instantiate correctly in a form usable by a dynamically loadable plugin, particularly across multiple platforms. While it is perfectly reasonable to write code in C++, the code must be self-contained and thus written in a somewhat minimalistic style compared to normal C++ coding practices. In particular, anything that would normally be initialized by the C++ runtime library before <a class="el" href="main_8c.html#a3">main</a>() would get called in a regular program will fail to operate correctly when used in a plugin, since there's no opportunity for the C++ runtime system to be invoked when a plugin is loaded by VMD. All initialization must happen within the register and init entry points, there can't be any dependencies on automatic  initializations normally provided by the compiler that would be found in a regular program.
<p>

<p>
 Another major issue associated with making the plugin interface reliable  involves assuring that memory allocated by the plugin interface (VMD) is  deallocated by the interface (VMD), and that memory allocated by a plugin  is deallocated by the same plugin. This also ensures that compilers with  incompatible memory allocation systems can be used to build plugins that  VMD can still use effectively. This also avoids problems that can occur  with the implementation of memory allocation with dynamic link libraries  on Microsoft Windows with the same compiler, but with different runtime library settings.
<p>

<p>
 <h3>Data structures, flags, and return codes used in molfile plugins</h3>
 The key data structures used by molfile plugins when communicating with VMD are <a class="el" href="structmolfile__metadata__t.html">molfile_metadata_t</a>, <a class="el" href="structmolfile__atom__t.html">molfile_atom_t</a>, <a class="el" href="structmolfile__timestep__t.html">molfile_timestep_t</a>,  <a class="el" href="structmolfile__volumetric__t.html">molfile_volumetric_t</a>, and <a class="el" href="structmolfile__graphics__t.html">molfile_graphics_t</a>. Each of these structures is used with matching plugin entry points that operate on the appropriate type of data. These structures consist of elementary strings, integers, and floats, which are easily handled by code written in C, C++, Tcl, and  presumably any other language one might want to use in writing  a VMD plugin. Molecule data flags are stored as integers created by binary ORing  several optional data availability flags together. The flags are used to indicate the presence of optional data fields, and to help VMD  combine newly loaded data with any existing molecular structure already in VMD. Every plugin entry point is expected to return the appropriate  status code based on the results of the attempted reading/writing operations. If no errors occur then MOLFILE_SUCCESS is returned. The symbolic constants MOLFILE_NUMATOMS_NONE and MOLFILE_NUMATOMS_UNKNOWN are used to improve code readability rather than returning 0 or -1 directly.
<p>

<p>
 <h3>Atom naming conventions used by VMD</h3>
 For various historical reasons, the atom and residue names VMD currently  looks for when analyzing structures and generating representations are  based on the atom and residue names assigned by the PDB.  Current versions of VMD use PDB-like atom names to identify protein and nucleic acid residues, for secondary  structure calculations using the STRIDE program (which takes input  structures in PDB format), and for rendering Cartoon and Ribbon  representations. The atom names that VMD currently looks for and their use are listed explicitly below:
<p>
<pre>
Protein detection (initial structure analysis):
  CA, C, O, N, OT1, OT2, O1, O2
  
Nucleic acid detection (initial structure analysis):
  O1P, O2P, O3', C3', C4', C5', O5', O3*, C3*, C4*, C5*, O5*

Atom names use when buildign Cartoon/Ribbon reps:
  CA, O, OT1, P

Residue names VMD looks for when identifying water:
  H2O, HH0, OHH, HOH, OH2, SOL, WAT, TIP, TIP2, TIP3, TIP4

Residue names VMD looks for when drawing nucleic acids:
  ADE, CYT, GUA, THY
</pre>
<p>

<p>
 <h3>Example: AMBER Parm reader plugin</h3>
 The AMBER Parm reader <a class="el" href="parmplugin_8C.html">parmplugin.C</a> is a plugin for reading structure information (only bond information in this case) into VMD. Private data is stored in a <a class="el" href="structparmdata.html">parmdata</a> structure, consisting of the file handle, number of atoms, bond arrays, and a pointer to a <a class="el" href="classReadPARM.html">ReadPARM</a> structure used by lower level reader code. As with many plugins, the Parm reader plugin was developed using an older generation of VMD molecule file reader code as the starting point. Rather than rewriting the old code from  scratch, the plugin simply wraps the old routines which were well tested and battle proven, with the necessary glue code to make them work within the appropriate molfile plugin entry points. The entry points implemented in the Parm reader are <a class="el" href="parmplugin_8C.html#a1">open_parm_read</a>(), <a class="el" href="parmplugin_8C.html#a2">read_parm_structure</a>(),  <a class="el" href="parmplugin_8C.html#a3">read_parm_bonds</a>(), and <a class="el" href="parmplugin_8C.html#a4">close_parm_read</a>(). The <a class="el" href="parmplugin_8C.html#a1">open_parm_read</a>() procedure opens the file, allocates the <a class="el" href="structparmdata.html">parmdata</a> private data handle, and reads metadata, such as the  number of atoms, needed by the subsequent structure reading functions.  The <a class="el" href="parmplugin_8C.html#a2">read_parm_structure</a>() procedure loops over all atoms reading in the atom names, types, charges, masses, and so on by calling the functions implemented by the older Parm reader code in <a class="el" href="ReadPARM_8h.html">ReadPARM.h</a>. Bond lists (1-based indexing) are returned by the <a class="el" href="parmplugin_8C.html#a3">read_parm_bonds</a>()  procedure. Since the Parm reader plugin doesn't provide bond order  information, the bond order pointer is set to NULL. The <a class="el" href="parmplugin_8C.html#a4">close_parm_read</a>() procedure frees memory and closes the open  Parm file handle, destroying all resources used by the file reading context.
<p>

<p>
 <h3>Example: Situs volumetric grid reader plugin</h3>
 The Situs plugin <a class="el" href="situsplugin_8C.html">situsplugin.C</a> is a relatively  simple example of how one can write a volumetric grid reader plugin. The <a class="el" href="structsitus__t.html">situs_t</a> structure contains private data needed in parsing and interpreting the contents of the Situs grid file. The <a class="el" href="situsplugin_8C.html#a1">open_situs_read</a>() procedure opens the Situs grid, saves the file handle and some elementary metadata about the file in the <a class="el" href="structsitus__t.html">situs_t</a> handle, and returns the <a class="el" href="structsitus__t.html">situs_t</a> handle for use in subsequent calls reading the the volumetric data contained in the file. The <a class="el" href="situsplugin_8C.html#a2">read_situs_metadata</a>() routine simply reuses the contents of the <a class="el" href="structsitus__t.html">situs_t</a> structure which was populated when the file was first opened, returning the number of datasets contained in the file and a list of their associated volumetric metadata such as grid size, origin, etc. The <a class="el" href="situsplugin_8C.html#a3">read_situs_data</a>() procedure loads the Situs grid data into the provided datablock pointer. As you may have already guessed, the <a class="el" href="situsplugin_8C.html#a4">close_situs_read</a>() procedure closes the open file handles, frees all memory allocation in the private <a class="el" href="structsitus__t.html">situs_t</a> handle, returning all resources used in that file reading context back to  the operating system. Since the Situs plugin doesn't read any atomic information, all of the function pointers related to atomic data are left NULL by the <a class="el" href="vmdplugin_8h.html#a3">VMDPLUGIN_register</a>() in <a class="el" href="situsplugin_8C.html">situsplugin.C</a>.
<p>
<hr><address><small>Generated on Wed Mar 22 13:15:37 2006 for VMD Plugins (current) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
