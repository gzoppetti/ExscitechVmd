<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>hash.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>hash.c</h1><a href="hash_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/***************************************************************************</font>
00002 <font class="comment"> *cr</font>
00003 <font class="comment"> *cr            (C) Copyright 1995-2006 The Board of Trustees of the</font>
00004 <font class="comment"> *cr                        University of Illinois</font>
00005 <font class="comment"> *cr                         All Rights Reserved</font>
00006 <font class="comment"> *cr</font>
00007 <font class="comment"> ***************************************************************************/</font>
00008 
00009 <font class="comment">/***************************************************************************</font>
00010 <font class="comment"> * RCS INFORMATION:</font>
00011 <font class="comment"> *</font>
00012 <font class="comment"> *      $RCSfile: hash.c,v $</font>
00013 <font class="comment"> *      $Author: johns $        $Locker:  $             $State: Exp $</font>
00014 <font class="comment"> *      $Revision: 1.4 $      $Date: 2006/01/05 00:05:53 $</font>
00015 <font class="comment"> *</font>
00016 <font class="comment"> ***************************************************************************</font>
00017 <font class="comment"> * DESCRIPTION:</font>
00018 <font class="comment"> *   A simple hash table implementation for strings, contributed by John Stone,</font>
00019 <font class="comment"> *   derived from his ray tracer code.</font>
00020 <font class="comment"> ***************************************************************************/</font>
00021 
00022 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00023 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00024 <font class="preprocessor">#include &lt;string.h&gt;</font>
00025 <font class="preprocessor">#include "<a class="code" href="hash_8h.html">hash.h</a>"</font>
00026 
<a name="l00027"></a><a class="code" href="hash_8c.html#a0">00027</a> <font class="preprocessor">#define HASH_LIMIT 0.5</font>
00028 <font class="preprocessor"></font>
<a name="l00030"></a><a class="code" href="structhash__node__t.html">00030</a> <font class="keyword">typedef</font> <font class="keyword">struct </font><a class="code" href="structhash__node__t.html">hash_node_t</a> {
<a name="l00031"></a><a class="code" href="structhash__node__t.html#m0">00031</a>   <font class="keywordtype">int</font> <a class="code" href="structhash__node__t.html#m0">data</a>;                           <font class="comment">/* data in hash node */</font>
<a name="l00032"></a><a class="code" href="structhash__node__t.html#m1">00032</a>   <font class="keyword">const</font> <font class="keywordtype">char</font> * <a class="code" href="structhash__node__t.html#m1">key</a>;                   <font class="comment">/* key for hash lookup */</font>
<a name="l00033"></a><a class="code" href="structhash__node__t.html#m2">00033</a>   <font class="keyword">struct </font><a class="code" href="structhash__node__t.html">hash_node_t</a> *next;           <font class="comment">/* next node in hash chain */</font>
00034 } <a class="code" href="structhash__node__t.html">hash_node_t</a>;
00035 
00036 <font class="comment">/*</font>
00037 <font class="comment"> *  hash() - Hash function returns a hash number for a given key.</font>
00038 <font class="comment"> *</font>
00039 <font class="comment"> *  tptr: Pointer to a hash table</font>
00040 <font class="comment"> *  key: The key to create a hash number for</font>
00041 <font class="comment"> */</font>
<a name="l00042"></a><a class="code" href="hash_8c.html#a2">00042</a> <font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="hash_8c.html#a2">hash</a>(<font class="keyword">const</font> <a class="code" href="structhash__t.html">hash_t</a> *tptr, <font class="keyword">const</font> <font class="keywordtype">char</font> *key) {
00043   <font class="keywordtype">int</font> i=0;
00044   <font class="keywordtype">int</font> hashvalue;
00045  
00046   <font class="keywordflow">while</font> (*key != <font class="charliteral">'\0'</font>)
00047     i=(i&lt;&lt;3)+(*key++ - <font class="charliteral">'0'</font>);
00048  
00049   hashvalue = (((i*1103515249)&gt;&gt;tptr-&gt;<a class="code" href="structhash__t.html#m3">downshift</a>) &amp; tptr-&gt;<a class="code" href="structhash__t.html#m4">mask</a>);
00050   <font class="keywordflow">if</font> (hashvalue &lt; 0) {
00051     hashvalue = 0;
00052   }    
00053 
00054   <font class="keywordflow">return</font> hashvalue;
00055 }
00056 
00057 <font class="comment">/*</font>
00058 <font class="comment"> *  hash_init() - Initialize a new hash table.</font>
00059 <font class="comment"> *</font>
00060 <font class="comment"> *  tptr: Pointer to the hash table to initialize</font>
00061 <font class="comment"> *  buckets: The number of initial buckets to create</font>
00062 <font class="comment"> */</font>
<a name="l00063"></a><a class="code" href="hash_8c.html#a3">00063</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">void</font> <a class="code" href="hash_8c.html#a3">hash_init</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr, <font class="keywordtype">int</font> buckets) {
00064 
00065   <font class="comment">/* make sure we allocate something */</font>
00066   <font class="keywordflow">if</font> (buckets==0)
00067     buckets=16;
00068 
00069   <font class="comment">/* initialize the table */</font>
00070   tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a>=0;
00071   tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>=2;
00072   tptr-&gt;<a class="code" href="structhash__t.html#m4">mask</a>=1;
00073   tptr-&gt;<a class="code" href="structhash__t.html#m3">downshift</a>=29;
00074 
00075   <font class="comment">/* ensure buckets is a power of 2 */</font>
00076   <font class="keywordflow">while</font> (tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>&lt;buckets) {
00077     tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>&lt;&lt;=1;
00078     tptr-&gt;<a class="code" href="structhash__t.html#m4">mask</a>=(tptr-&gt;<a class="code" href="structhash__t.html#m4">mask</a>&lt;&lt;1)+1;
00079     tptr-&gt;<a class="code" href="structhash__t.html#m3">downshift</a>--;
00080   } <font class="comment">/* while */</font>
00081 
00082   <font class="comment">/* allocate memory for table */</font>
00083   tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>=(<a class="code" href="structhash__node__t.html">hash_node_t</a> **) calloc(tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>, <font class="keyword">sizeof</font>(<a class="code" href="structhash__node__t.html">hash_node_t</a> *));
00084 
00085   <font class="keywordflow">return</font>;
00086 }
00087 
00088 <font class="comment">/*</font>
00089 <font class="comment"> *  rebuild_table() - Create new hash table when old one fills up.</font>
00090 <font class="comment"> *</font>
00091 <font class="comment"> *  tptr: Pointer to a hash table</font>
00092 <font class="comment"> */</font>
<a name="l00093"></a><a class="code" href="hash_8c.html#a4">00093</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="hash_8c.html#a4">rebuild_table</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr) {
00094   <a class="code" href="structhash__node__t.html">hash_node_t</a> **old_bucket, *old_hash, *tmp;
00095   <font class="keywordtype">int</font> old_size, h, i;
00096 
00097   old_bucket=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>;
00098   old_size=tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>;
00099 
00100   <font class="comment">/* create a new table and rehash old buckets */</font>
00101   <a class="code" href="hash_8c.html#a3">hash_init</a>(tptr, old_size&lt;&lt;1);
00102   <font class="keywordflow">for</font> (i=0; i&lt;old_size; i++) {
00103     old_hash=old_bucket[i];
00104     <font class="keywordflow">while</font>(old_hash) {
00105       tmp=old_hash;
00106       old_hash=old_hash-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>;
00107       h=<a class="code" href="hash_8c.html#a2">hash</a>(tptr, tmp-&gt;<a class="code" href="structhash__node__t.html#m1">key</a>);
00108       tmp-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h];
00109       tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]=tmp;
00110       tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a>++;
00111     } <font class="comment">/* while */</font>
00112   } <font class="comment">/* for */</font>
00113 
00114   <font class="comment">/* free memory used by old table */</font>
00115   free(old_bucket);
00116 
00117   <font class="keywordflow">return</font>;
00118 }
00119 
00120 <font class="comment">/*</font>
00121 <font class="comment"> *  hash_lookup() - Lookup an entry in the hash table and return a pointer to</font>
00122 <font class="comment"> *    it or HASH_FAIL if it wasn't found.</font>
00123 <font class="comment"> *</font>
00124 <font class="comment"> *  tptr: Pointer to the hash table</font>
00125 <font class="comment"> *  key: The key to lookup</font>
00126 <font class="comment"> */</font>
<a name="l00127"></a><a class="code" href="hash_8c.html#a5">00127</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">int</font> <a class="code" href="hash_8c.html#a5">hash_lookup</a>(<font class="keyword">const</font> <a class="code" href="structhash__t.html">hash_t</a> *tptr, <font class="keyword">const</font> <font class="keywordtype">char</font> *key) {
00128   <font class="keywordtype">int</font> h;
00129   <a class="code" href="structhash__node__t.html">hash_node_t</a> *node;
00130 
00131 
00132   <font class="comment">/* find the entry in the hash table */</font>
00133   h=<a class="code" href="hash_8c.html#a2">hash</a>(tptr, key);
00134   <font class="keywordflow">for</font> (node=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]; node!=NULL; node=node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>) {
00135     <font class="keywordflow">if</font> (!strcmp(node-&gt;<a class="code" href="structhash__node__t.html#m1">key</a>, key))
00136       <font class="keywordflow">break</font>;
00137   }
00138 
00139   <font class="comment">/* return the entry if it exists, or HASH_FAIL */</font>
00140   <font class="keywordflow">return</font>(node ? node-&gt;<a class="code" href="structhash__node__t.html#m0">data</a> : <a class="code" href="hash_8h.html#a0">HASH_FAIL</a>);
00141 }
00142 
00143 <font class="comment">/*</font>
00144 <font class="comment"> *  hash_insert() - Insert an entry into the hash table.  If the entry already</font>
00145 <font class="comment"> *  exists return a pointer to it, otherwise return HASH_FAIL.</font>
00146 <font class="comment"> *</font>
00147 <font class="comment"> *  tptr: A pointer to the hash table</font>
00148 <font class="comment"> *  key: The key to insert into the hash table</font>
00149 <font class="comment"> *  data: A pointer to the data to insert into the hash table</font>
00150 <font class="comment"> */</font>
<a name="l00151"></a><a class="code" href="hash_8c.html#a6">00151</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">int</font> <a class="code" href="hash_8c.html#a6">hash_insert</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr, <font class="keyword">const</font> <font class="keywordtype">char</font> *key, <font class="keywordtype">int</font> data) {
00152   <font class="keywordtype">int</font> tmp;
00153   <a class="code" href="structhash__node__t.html">hash_node_t</a> *node;
00154   <font class="keywordtype">int</font> h;
00155 
00156   <font class="comment">/* check to see if the entry exists */</font>
00157   <font class="keywordflow">if</font> ((tmp=<a class="code" href="hash_8c.html#a5">hash_lookup</a>(tptr, key)) != <a class="code" href="hash_8h.html#a0">HASH_FAIL</a>)
00158     <font class="keywordflow">return</font>(tmp);
00159 
00160   <font class="comment">/* expand the table if needed */</font>
00161   <font class="keywordflow">while</font> (tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a>&gt;=<a class="code" href="hash_8c.html#a0">HASH_LIMIT</a>*tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>)
00162     <a class="code" href="hash_8c.html#a4">rebuild_table</a>(tptr);
00163 
00164   <font class="comment">/* insert the new entry */</font>
00165   h=<a class="code" href="hash_8c.html#a2">hash</a>(tptr, key);
00166   node=(<font class="keyword">struct </font><a class="code" href="structhash__node__t.html">hash_node_t</a> *) malloc(sizeof(hash_node_t));
00167   node-&gt;<a class="code" href="structhash__node__t.html#m0">data</a>=data;
00168   node-&gt;<a class="code" href="structhash__node__t.html#m1">key</a>=key;
00169   node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h];
00170   tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]=node;
00171   tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a>++;
00172 
00173   <font class="keywordflow">return</font> <a class="code" href="hash_8h.html#a0">HASH_FAIL</a>;
00174 }
00175 
00176 <font class="comment">/*</font>
00177 <font class="comment"> *  hash_delete() - Remove an entry from a hash table and return a pointer</font>
00178 <font class="comment"> *  to its data or HASH_FAIL if it wasn't found.</font>
00179 <font class="comment"> *</font>
00180 <font class="comment"> *  tptr: A pointer to the hash table</font>
00181 <font class="comment"> *  key: The key to remove from the hash table</font>
00182 <font class="comment"> */</font>
<a name="l00183"></a><a class="code" href="hash_8c.html#a7">00183</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">int</font> <a class="code" href="hash_8c.html#a7">hash_delete</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr, <font class="keyword">const</font> <font class="keywordtype">char</font> *key) {
00184   <a class="code" href="structhash__node__t.html">hash_node_t</a> *node, *last;
00185   <font class="keywordtype">int</font> data;
00186   <font class="keywordtype">int</font> h;
00187 
00188   <font class="comment">/* find the node to remove */</font>
00189   h=<a class="code" href="hash_8c.html#a2">hash</a>(tptr, key);
00190   <font class="keywordflow">for</font> (node=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]; node; node=node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>) {
00191     <font class="keywordflow">if</font> (!strcmp(node-&gt;<a class="code" href="structhash__node__t.html#m1">key</a>, key))
00192       <font class="keywordflow">break</font>;
00193   }
00194 
00195   <font class="comment">/* Didn't find anything, return HASH_FAIL */</font>
00196   <font class="keywordflow">if</font> (node==NULL)
00197     <font class="keywordflow">return</font> <a class="code" href="hash_8h.html#a0">HASH_FAIL</a>;
00198 
00199   <font class="comment">/* if node is at head of bucket, we have it easy */</font>
00200   <font class="keywordflow">if</font> (node==tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h])
00201     tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]=node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>;
00202   <font class="keywordflow">else</font> {
00203     <font class="comment">/* find the node before the node we want to remove */</font>
00204     <font class="keywordflow">for</font> (last=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[h]; last &amp;&amp; last-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>; last=last-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>) {
00205       <font class="keywordflow">if</font> (last-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>==node)
00206         <font class="keywordflow">break</font>;
00207     }
00208     last-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>=node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>;
00209   }
00210 
00211   <font class="comment">/* free memory and return the data */</font>
00212   data=node-&gt;<a class="code" href="structhash__node__t.html#m0">data</a>;
00213   free(node);
00214 
00215   <font class="keywordflow">return</font>(data);
00216 }
00217 
00218 
00219 
00220 <font class="comment">/*</font>
00221 <font class="comment"> * hash_destroy() - Delete the entire table, and all remaining entries.</font>
00222 <font class="comment"> * </font>
00223 <font class="comment"> */</font>
<a name="l00224"></a><a class="code" href="hash_8c.html#a8">00224</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">void</font> <a class="code" href="hash_8c.html#a8">hash_destroy</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr) {
00225   <a class="code" href="structhash__node__t.html">hash_node_t</a> *node, *last;
00226   <font class="keywordtype">int</font> i;
00227 
00228   <font class="keywordflow">for</font> (i=0; i&lt;tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>; i++) {
00229     node = tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[i];
00230     <font class="keywordflow">while</font> (node != NULL) { 
00231       last = node;   
00232       node = node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>;
00233       free(last);
00234     }
00235   }     
00236 
00237   <font class="comment">/* free the entire array of buckets */</font>
00238   <font class="keywordflow">if</font> (tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a> != NULL) {
00239     free(tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>);
00240     memset(tptr, 0, <font class="keyword">sizeof</font>(<a class="code" href="structhash__t.html">hash_t</a>));
00241   }
00242 }
00243 
00244 <font class="comment">/*</font>
00245 <font class="comment"> *  alos() - Find the average length of search.</font>
00246 <font class="comment"> *</font>
00247 <font class="comment"> *  tptr: Pointer to a hash table</font>
00248 <font class="comment"> */</font>
<a name="l00249"></a><a class="code" href="hash_8c.html#a9">00249</a> <font class="keyword">static</font> <font class="keywordtype">float</font> <a class="code" href="hash_8c.html#a9">alos</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr) {
00250   <font class="keywordtype">int</font> i,j;
00251   <font class="keywordtype">float</font> <a class="code" href="hash_8c.html#a9">alos</a>=0;
00252   <a class="code" href="structhash__node__t.html">hash_node_t</a> *node;
00253 
00254 
00255   <font class="keywordflow">for</font> (i=0; i&lt;tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>; i++) {
00256     <font class="keywordflow">for</font> (node=tptr-&gt;<a class="code" href="structhash__t.html#m0">bucket</a>[i], j=0; node!=NULL; node=node-&gt;<a class="code" href="structhash__node__t.html#m2">next</a>, j++);
00257     <font class="keywordflow">if</font> (j)
00258       <a class="code" href="hash_8c.html#a9">alos</a>+=((j*(j+1))&gt;&gt;1);
00259   } <font class="comment">/* for */</font>
00260 
00261   <font class="keywordflow">return</font>(tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a> ? <a class="code" href="hash_8c.html#a9">alos</a>/tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a> : 0);
00262 }
00263 
00264 
00265 <font class="comment">/*</font>
00266 <font class="comment"> *  hash_stats() - Return a string with stats about a hash table.</font>
00267 <font class="comment"> *</font>
00268 <font class="comment"> *  tptr: A pointer to the hash table</font>
00269 <font class="comment"> */</font>
<a name="l00270"></a><a class="code" href="hash_8c.html#a10">00270</a> <a class="code" href="hash_8h.html#a1">VMDEXTERNSTATIC</a> <font class="keywordtype">char</font> * <a class="code" href="hash_8c.html#a10">hash_stats</a>(<a class="code" href="structhash__t.html">hash_t</a> *tptr) {
00271   <font class="keyword">static</font> <font class="keywordtype">char</font> buf[1024];
00272 
00273   sprintf(buf, <font class="stringliteral">"%u slots, %u entries, and %1.2f ALOS"</font>,
00274     (<font class="keywordtype">int</font>)tptr-&gt;<a class="code" href="structhash__t.html#m1">size</a>, (<font class="keywordtype">int</font>)tptr-&gt;<a class="code" href="structhash__t.html#m2">entries</a>, <a class="code" href="hash_8c.html#a9">alos</a>(tptr));
00275 
00276   <font class="keywordflow">return</font>(buf);
00277 }
00278 
00279 
00280 
00281 
</pre></div><hr><address><small>Generated on Wed Mar 22 13:15:30 2006 for VMD Plugins (current) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
