<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>endianswap.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>endianswap.h</h1><a href="endianswap_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/***************************************************************************</font>
00002 <font class="comment"> *cr</font>
00003 <font class="comment"> *cr            (C) Copyright 1995-2006 The Board of Trustees of the</font>
00004 <font class="comment"> *cr                        University of Illinois</font>
00005 <font class="comment"> *cr                         All Rights Reserved</font>
00006 <font class="comment"> *cr</font>
00007 <font class="comment"> ***************************************************************************/</font>
00008 <font class="comment">/***************************************************************************</font>
00009 <font class="comment"> * RCS INFORMATION:</font>
00010 <font class="comment"> *</font>
00011 <font class="comment"> *      $RCSfile: endianswap.h,v $</font>
00012 <font class="comment"> *      $Author: johns $       $Locker:  $             $State: Exp $</font>
00013 <font class="comment"> *      $Revision: 1.5 $       $Date: 2006/01/05 00:05:52 $</font>
00014 <font class="comment"> *</font>
00015 <font class="comment"> ***************************************************************************</font>
00016 <font class="comment"> * DESCRIPTION:</font>
00017 <font class="comment"> *   Byte swapping routines used in various plugins</font>
00018 <font class="comment"> *   There are two versions of each routine, one that's safe to use in</font>
00019 <font class="comment"> *   all cases (but is slow) and one that is only safe to use on memory </font>
00020 <font class="comment"> *   addresses that are aligned to the word size that's being byte-swapped</font>
00021 <font class="comment"> *   but are much much much faster.  Use the aligned versions of these</font>
00022 <font class="comment"> *   routines whenever possible.  The 'ndata' length count parameters and</font>
00023 <font class="comment"> *   internal loops should be safe to use on huge memory arrays on 64-bit</font>
00024 <font class="comment"> *   machines.</font>
00025 <font class="comment"> *</font>
00026 <font class="comment"> ***************************************************************************/</font>
00027 
00028 <font class="preprocessor">#ifndef ENDIAN_SWAP_H</font>
00029 <font class="preprocessor"></font><font class="preprocessor">#define ENDIAN_SWAP_H</font>
00030 <font class="preprocessor"></font>
00031 <font class="comment">/* works on unaligned 2-byte quantities */</font>
<a name="l00032"></a><a class="code" href="endianswap_8h.html#a0">00032</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a0">swap2_unaligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00033   <font class="keywordtype">long</font> i;
00034   <font class="keywordtype">char</font> * dataptr = (<font class="keywordtype">char</font> *) v;
00035   <font class="keywordtype">char</font> tmp;
00036 
00037   <font class="keywordflow">for</font> (i = 0; i &lt; ndata-1; i += 2) {
00038     tmp = dataptr[i];
00039     dataptr[i] = dataptr[i+1];
00040     dataptr[i+1] = tmp;
00041   }
00042 }
00043 
00044 
00045 <font class="comment">/* works on unaligned 4-byte quantities */</font>
<a name="l00046"></a><a class="code" href="endianswap_8h.html#a1">00046</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a1">swap4_unaligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00047   <font class="keywordtype">long</font> i;
00048   <font class="keywordtype">char</font> *dataptr;
00049   <font class="keywordtype">char</font> tmp;
00050 
00051   dataptr = (<font class="keywordtype">char</font> *) v; 
00052   <font class="keywordflow">for</font> (i=0; i&lt;ndata; i++) {
00053     tmp = dataptr[0];
00054     dataptr[0] = dataptr[3];
00055     dataptr[3] = tmp;
00056     tmp = dataptr[1];
00057     dataptr[1] = dataptr[2];
00058     dataptr[2] = tmp;
00059     dataptr += 4;
00060   }
00061 }
00062 
00063 
00064 <font class="comment">/* works on unaligned 8-byte quantities */</font>
<a name="l00065"></a><a class="code" href="endianswap_8h.html#a2">00065</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a2">swap8_unaligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00066   <font class="keywordtype">char</font> *data = (<font class="keywordtype">char</font> *) v;
00067   <font class="keywordtype">long</font> i;
00068   <font class="keywordtype">char</font> byteArray[8];
00069   <font class="keywordtype">char</font> *bytePointer;
00070 
00071   <font class="keywordflow">for</font> (i=0; i&lt;ndata; i++) {
00072     bytePointer = data + (i&lt;&lt;3);
00073     byteArray[0]  =  *bytePointer;
00074     byteArray[1]  =  *(bytePointer+1);
00075     byteArray[2]  =  *(bytePointer+2);
00076     byteArray[3]  =  *(bytePointer+3);
00077     byteArray[4]  =  *(bytePointer+4);
00078     byteArray[5]  =  *(bytePointer+5);
00079     byteArray[6]  =  *(bytePointer+6);
00080     byteArray[7]  =  *(bytePointer+7);
00081 
00082     *bytePointer     = byteArray[7];
00083     *(bytePointer+1) = byteArray[6];
00084     *(bytePointer+2) = byteArray[5];
00085     *(bytePointer+3) = byteArray[4];
00086     *(bytePointer+4) = byteArray[3];
00087     *(bytePointer+5) = byteArray[2];
00088     *(bytePointer+6) = byteArray[1];
00089     *(bytePointer+7) = byteArray[0];
00090   }
00091 }
00092 
00093 
00094 <font class="comment">/* Only works with aligned 2-byte quantities, will cause a bus error */</font>
00095 <font class="comment">/* on some platforms if used on unaligned data.                      */</font>
<a name="l00096"></a><a class="code" href="endianswap_8h.html#a3">00096</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a3">swap2_aligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00097   <font class="keywordtype">short</font> *data = (<font class="keywordtype">short</font> *) v;
00098   <font class="keywordtype">long</font> i;
00099   <font class="keywordtype">short</font> *N; 
00100 
00101   <font class="keywordflow">for</font> (i=0; i&lt;ndata; i++) {
00102     N = data + i;
00103     *N=(((*N&gt;&gt;8)&amp;0xff) | ((*N&amp;0xff)&lt;&lt;8));  
00104   }
00105 }
00106 
00107 
00108 <font class="comment">/* Only works with aligned 4-byte quantities, will cause a bus error */</font>
00109 <font class="comment">/* on some platforms if used on unaligned data.                      */</font>
<a name="l00110"></a><a class="code" href="endianswap_8h.html#a4">00110</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a4">swap4_aligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00111   <font class="keywordtype">int</font> *data = (<font class="keywordtype">int</font> *) v;
00112   <font class="keywordtype">long</font> i;
00113   <font class="keywordtype">int</font> *N;
00114   <font class="keywordflow">for</font> (i=0; i&lt;ndata; i++) {
00115     N = data + i;
00116     *N=(((*N&gt;&gt;24)&amp;0xff) | ((*N&amp;0xff)&lt;&lt;24) | 
00117         ((*N&gt;&gt;8)&amp;0xff00) | ((*N&amp;0xff00)&lt;&lt;8));
00118   }
00119 }
00120 
00121 
00122 <font class="comment">/* Only works with aligned 8-byte quantities, will cause a bus error */</font>
00123 <font class="comment">/* on some platforms if used on unaligned data.                      */</font>
<a name="l00124"></a><a class="code" href="endianswap_8h.html#a5">00124</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="endianswap_8h.html#a5">swap8_aligned</a>(<font class="keywordtype">void</font> *v, <font class="keywordtype">long</font> ndata) {
00125   <font class="comment">/* Use int* internally to prevent bugs caused by some compilers */</font>
00126   <font class="comment">/* and hardware that would potentially load data into an FP reg */</font>
00127   <font class="comment">/* and hose everything, such as the old "jmemcpy()" bug in NAMD */</font>
00128   <font class="keywordtype">int</font> *data = (<font class="keywordtype">int</font> *) v;  
00129   <font class="keywordtype">long</font> i;
00130   <font class="keywordtype">int</font> *N; 
00131   <font class="keywordtype">int</font> t0, t1;
00132 
00133   <font class="keywordflow">for</font> (i=0; i&lt;ndata; i++) {
00134     N = data + (i&lt;&lt;1);
00135     t0 = N[0];
00136     t0=(((t0&gt;&gt;24)&amp;0xff) | ((t0&amp;0xff)&lt;&lt;24) | 
00137         ((t0&gt;&gt;8)&amp;0xff00) | ((t0&amp;0xff00)&lt;&lt;8));
00138 
00139     t1 = N[1];
00140     t1=(((t1&gt;&gt;24)&amp;0xff) | ((t1&amp;0xff)&lt;&lt;24) | 
00141         ((t1&gt;&gt;8)&amp;0xff00) | ((t1&amp;0xff00)&lt;&lt;8));
00142 
00143     N[0] = t1; 
00144     N[1] = t0; 
00145   }
00146 }
00147 
00148 <font class="preprocessor">#if 0</font>
00149 <font class="preprocessor"></font><font class="comment">/* Other implementations that might be faster in some cases */</font>
00150 
00151 <font class="comment">/* swaps the endianism of an eight byte word. */</font>
00152 <font class="keywordtype">void</font> mdio_swap8(<font class="keywordtype">double</font> *i) {
00153         <font class="keywordtype">char</font> c;
00154         <font class="keywordtype">char</font> *n;
00155         n = (<font class="keywordtype">char</font> *) i;
00156         c = n[0];
00157         n[0] = n[7];
00158         n[7] = c;
00159         c = n[1];
00160         n[1] = n[6];
00161         n[6] = c;
00162         c = n[2];
00163         n[2] = n[5];
00164         n[5] = c;
00165         c = n[3];
00166         n[3] = n[4];
00167         n[4] = c;
00168 }
00169 
00170 <font class="preprocessor">#endif</font>
00171 <font class="preprocessor"></font>
00172 <font class="preprocessor">#endif</font>
00173 <font class="preprocessor"></font>
</pre></div><hr><address><small>Generated on Wed Mar 22 13:15:29 2006 for VMD Plugins (current) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
